// Copyright © 2024–2026 Yuze Pan. 保留一切权利。

//
//  ClipboardItem.swift
//  Deck
//
//  Deck Clipboard Manager
//

import AppKit
import Observation
import UniformTypeIdentifiers
import QuickLookThumbnailing
import PDFKit

typealias PasteboardType = NSPasteboard.PasteboardType

extension PasteboardType {
    // Image types first to prioritize image detection over fileURL
    static var supportedTypes: [PasteboardType] = [
        .png, .tiff, .jpeg, .heic, .heif, .gif, .webp, .bmp, .rtfd, .flatRTFD, .rtf, .fileURL, .string
    ]

    static let jpeg = NSPasteboard.PasteboardType("public.jpeg")
    static let heic = NSPasteboard.PasteboardType("public.heic")
    static let heif = NSPasteboard.PasteboardType("public.heif")
    static let gif = NSPasteboard.PasteboardType("com.compuserve.gif")
    static let webp = NSPasteboard.PasteboardType("org.webmproject.webp")
    static let bmp = NSPasteboard.PasteboardType("com.microsoft.bmp")
    static let flatRTFD = NSPasteboard.PasteboardType("com.apple.flat-rtfd")
    static let microsoftObjectLink = NSPasteboard.PasteboardType(rawValue: "com.microsoft.ObjectLink")
    static let microsoftLinkSource = NSPasteboard.PasteboardType(rawValue: "com.microsoft.Link-Source")
    static let universalClipboard = NSPasteboard.PasteboardType(rawValue: "com.apple.is-remote-clipboard")
    static let autoGenerated = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.AutoGeneratedType")
    static let concealed = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.ConcealedType")
    static let source = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.source")
    static let transient = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.TransientType")
    static let modified = NSPasteboard.PasteboardType(rawValue: "x.nspasteboard.ModifiedType")
    static let fromMaccy = NSPasteboard.PasteboardType(rawValue: "org.p0deje.Maccy")
    static let linkPresentationMetadata = NSPasteboard.PasteboardType(rawValue: "com.apple.linkpresentation.metadata")
    static let customWebKitPasteboardData = NSPasteboard.PasteboardType(rawValue: "com.apple.WebKit.custom-pasteboard-data")
    static let customChromiumWebData = NSPasteboard.PasteboardType(rawValue: "org.chromium.web-custom-data")
    static let chromiumSourceUrl = NSPasteboard.PasteboardType(rawValue: "org.chromium.source-url")
    static let chromiumSourceToken = NSPasteboard.PasteboardType(rawValue: "org.chromium.internal.source-rfh-token")
    static let notesRichText = NSPasteboard.PasteboardType(rawValue: "com.apple.notes.richtext")
    static let deckUnsupported = NSPasteboard.PasteboardType(rawValue: "com.deck.unsupported")
    
    func isImage() -> Bool {
        if [.png, .tiff, .jpeg, .heic, .heif, .gif, .webp, .bmp].contains(self) { return true }
        if let utType = UTType(self.rawValue) {
            return utType.conforms(to: .image)
        }
        return false
    }
    
    func isText() -> Bool {
        !isImage() && !isFile()
    }
    
    func isFile() -> Bool {
        self == .fileURL
    }
}

enum ClipItemType: String, Codable, Sendable {
    case text
    case richText
    case image
    case file
    case url
    case color
    case code
    
    var displayName: String {
        switch self {
        case .text: return NSLocalizedString("文本", comment: "Text")
        case .richText: return NSLocalizedString("富文本", comment: "Rich Text")
        case .image: return NSLocalizedString("图片", comment: "Image")
        case .file: return NSLocalizedString("文件", comment: "File")
        case .url: return NSLocalizedString("链接", comment: "URL")
        case .color: return NSLocalizedString("颜色", comment: "Color")
        case .code: return NSLocalizedString("代码", comment: "Code")
        }
    }
    
    var icon: String {
        switch self {
        case .text: return "doc.text"
        case .richText: return "doc.richtext"
        case .image: return "photo"
        case .file: return "doc"
        case .url: return "link"
        case .color: return "paintpalette"
        case .code: return "chevron.left.forwardslash.chevron.right"
        }
    }
}

struct FigmaClipboardMeta: Decodable {
    let fileKey: String?
    let pasteID: Int?
    let dataType: String?
}

struct FigmaClipboardPayload {
    let html: String
    let figmaBase64: String
    let figmetaBase64: String?
    let meta: FigmaClipboardMeta?
    let sourceURL: String?
    let pasteboardTypes: [String]
}

@Observable
final class ClipboardItem: Identifiable, Equatable {
    var id: Int64?
    let uniqueId: String
    let pasteboardType: PasteboardType
    @ObservationIgnored
    private var inlineData: Data
    let previewData: Data?
    let blobPath: String?
    private(set) var timestamp: Int64
    let appPath: String
    let appName: String
    var customTitle: String?
    var sourceAnchor: SourceAnchor?
    var searchText: String {
        didSet {
            guard searchText != oldValue else { return }
            base64ImageChecked = false
            cachedBase64Image = nil
            urlChecked = false
            cachedURL = nil
            analysisLock.lock()
            cachedSmartAnalysis = nil
            cachedIsMarkdown = nil
            cachedCalculationResult = nil
            calculationResultChecked = false
            analysisLock.unlock()
        }
    }
    let contentLength: Int
    var tagId: Int
    var isTemporary: Bool
    var isMissingFile: Bool = false

    @ObservationIgnored
    private var dataIsFull: Bool

    @ObservationIgnored
    private var fullDataLoader: (() -> Data?)?

    @ObservationIgnored
    private let dataLock = NSLock()

    @ObservationIgnored
    private let analysisLock = NSLock()
    
    @ObservationIgnored
    private(set) var itemType: ClipItemType = .text
    
    @ObservationIgnored
    private var cachedThumbnail: NSImage?
    
    @ObservationIgnored
    private var cachedImageSize: CGSize?
    
    @ObservationIgnored
    private var cachedFilePaths: [String]?

    @ObservationIgnored
    private var cachedNormalizedFilePaths: [String]?
    
    @ObservationIgnored
    private var cachedColorValue: NSColor?

    @ObservationIgnored
    private var cachedBase64Image: NSImage?

    @ObservationIgnored
    private var base64ImageChecked: Bool = false

    @ObservationIgnored
    private var urlChecked: Bool = false

    @ObservationIgnored
    private var cachedURL: URL?
    
    @ObservationIgnored
    private var analysisSample: String {
        Self.sampleText(searchText, maxLength: Const.maxSmartAnalysisLength)
    }

    private static func sampleText(_ text: String, maxLength: Int) -> String {
        guard maxLength > 0 else { return "" }

        guard let cut = text.index(text.startIndex, offsetBy: maxLength, limitedBy: text.endIndex),
              cut != text.endIndex else {
            return text
        }
        let headLen = maxLength / 2
        let tailLen = maxLength - headLen
        return String(text.prefix(headLen)) + "\n…\n" + String(text.suffix(tailLen))
    }
    
    @ObservationIgnored
    private var cachedSmartAnalysis: SmartTextService.DetectionResult?
    
    @ObservationIgnored
    private var cachedIsMarkdown: Bool?

    @ObservationIgnored
    private var cachedCalculationResult: SmartTextService.CalculationResult?

    @ObservationIgnored
    private var calculationResultChecked: Bool = false

    @ObservationIgnored
    private var figmaPayloadChecked: Bool = false

    @ObservationIgnored
    private var cachedFigmaPayload: FigmaClipboardPayload?

    @ObservationIgnored
    private var figmaPayloadLastAttempt: TimeInterval = 0
    
    var url: URL? {
        analysisLock.lock()
        if urlChecked {
            let cached = cachedURL
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        let result: URL?
        if pasteboardType == .string || itemType == .url {
            result = searchText.asCompleteURL()
        } else {
            result = nil
        }

        analysisLock.lock()
        cachedURL = result
        urlChecked = true
        analysisLock.unlock()
        return result
    }

    var displayTitle: String? {
        let trimmed = customTitle?.trimmingCharacters(in: .whitespacesAndNewlines)
        guard let trimmed, !trimmed.isEmpty else { return nil }
        return trimmed
    }

    var searchableText: String {
        var parts: [String] = []
        if let title = displayTitle {
            parts.append(title)
        }
        if !searchText.isEmpty {
            parts.append(searchText)
        }
        if !appName.isEmpty {
            parts.append(appName)
        }
        return parts.joined(separator: "\n")
    }

    var isUnsupported: Bool {
        pasteboardType == .deckUnsupported
    }

    var figmaClipboardPayload: FigmaClipboardPayload? {
        analysisLock.lock()
        if figmaPayloadChecked {
            let cached = cachedFigmaPayload
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        let result = resolveFigmaPayload()
        analysisLock.lock()
        if result.shouldCache {
            figmaPayloadChecked = true
            cachedFigmaPayload = result.payload
        }
        analysisLock.unlock()
        return result.payload
    }

    var isFigmaClipboard: Bool {
        figmaClipboardPayload != nil
    }
    
    var colorValue: NSColor? {
        analysisLock.lock()
        if let cached = cachedColorValue {
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        guard itemType == .color else { return nil }

        // Prefer normalized plain text when available (RTF/RTFD may not be UTF-8).
        let candidate = searchText.trimmingCharacters(in: .whitespacesAndNewlines)

        let result: NSColor?
        if let color = candidate.hexColor {
            result = color
        } else {
            let raw = (String(data: data, encoding: .utf8) ?? "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            result = raw.hexColor
        }

        analysisLock.lock()
        cachedColorValue = result
        analysisLock.unlock()
        return result
    }

    private func resolveFigmaPayload() -> (payload: FigmaClipboardPayload?, shouldCache: Bool) {
        guard isUnsupported else { return (nil, true) }
        if !hasFullData {
            let now = CFAbsoluteTimeGetCurrent()
            analysisLock.lock()
            let lastAttempt = figmaPayloadLastAttempt
            if now - lastAttempt < 0.5 {
                analysisLock.unlock()
                return (nil, false)
            }
            figmaPayloadLastAttempt = now
            analysisLock.unlock()
        }
        guard let payloadData = resolvedData(), !payloadData.isEmpty else {
            log.debug("Figma payload: empty data (id=\(id ?? -1), uniqueId=\(uniqueId))")
            return (nil, false)
        }
        let isFullData = hasFullData
        if let payload = UnsupportedPasteboardPayload.decode(from: payloadData) {
            if payload.items.isEmpty {
                log.debug("Figma payload: no items (id=\(id ?? -1))")
                return (nil, isFullData)
            }

            if let extracted = Self.extractFigmaPayload(from: payload.items, id: id) {
                return (extracted, true)
            }

            log.debug("Figma payload: no figma marker in HTML (id=\(id ?? -1))")
            return (nil, isFullData)
        }

        log.debug("Figma payload: decode failed, trying plist fallback (id=\(id ?? -1), size=\(payloadData.count))")
        if let extracted = Self.extractFigmaPayloadFromPlistFallback(payloadData, id: id) {
            log.debug("Figma payload: parsed via plist fallback (id=\(id ?? -1))")
            return (extracted, true)
        }

        log.debug("Figma payload: plist fallback failed (id=\(id ?? -1), size=\(payloadData.count))")
        return (nil, isFullData)
    }

    private static func extractFigmaPayload(
        from items: [UnsupportedPasteboardItem],
        id: Int64?
    ) -> FigmaClipboardPayload? {
        for item in items {
            guard let html = item.htmlString(), !html.isEmpty else { continue }
            if let payload = buildFigmaPayload(
                from: html,
                sourceURLData: item.dataByType["org.chromium.source-url"],
                pasteboardTypes: item.types,
                id: id
            ) {
                return payload
            }
        }
        return nil
    }

    private static func extractFigmaPayloadFromPlistFallback(
        _ data: Data,
        id: Int64?
    ) -> FigmaClipboardPayload? {
        guard let plist = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil),
              let dict = plist as? [String: Any],
              let items = dict["items"] as? [[String: Any]] else {
            return nil
        }

        for item in items {
            let dataByType = item["dataByType"] as? [String: Any] ?? [:]
            let stringByType = item["stringByType"] as? [String: Any] ?? [:]
            let html = decodeHTMLFromAny(stringByType["public.html"])
                ?? decodeHTMLFromAny(dataByType["public.html"])
            guard let html, !html.isEmpty else { continue }
            let sourceURLData = decodeDataFromAny(dataByType["org.chromium.source-url"])
            let types = (item["types"] as? [String])
                ?? Array(Set(dataByType.keys).union(stringByType.keys)).sorted()
            if let payload = buildFigmaPayload(
                from: html,
                sourceURLData: sourceURLData,
                pasteboardTypes: types,
                id: id
            ) {
                return payload
            }
        }
        return nil
    }

    private static func buildFigmaPayload(
        from html: String,
        sourceURLData: Data?,
        pasteboardTypes: [String],
        id: Int64?
    ) -> FigmaClipboardPayload? {
        guard let figmaBase64 = extractHTMLMarker("figma", from: html) else {
            log.debug("Figma payload: figma marker not found or extract failed (id=\(id ?? -1))")
            return nil
        }
        let figmetaBase64 = extractHTMLMarker("figmeta", from: html)
        let meta: FigmaClipboardMeta?
        if let figmetaBase64 {
            meta = decodeFigmaMeta(figmetaBase64)
        } else {
            meta = nil
        }
        let sourceURL = decodeStringFromData(sourceURLData)
        log.debug("Figma payload: parsed (id=\(id ?? -1), fileKey=\(meta?.fileKey ?? ""), pasteID=\(meta?.pasteID ?? -1))")
        return FigmaClipboardPayload(
            html: html,
            figmaBase64: figmaBase64,
            figmetaBase64: figmetaBase64,
            meta: meta,
            sourceURL: sourceURL,
            pasteboardTypes: pasteboardTypes
        )
    }

    private static func decodeDataFromAny(_ value: Any?) -> Data? {
        if let data = value as? Data { return data }
        if let data = value as? NSData { return data as Data }
        return nil
    }

    private static func decodeHTMLFromAny(_ value: Any?) -> String? {
        if let text = value as? String { return text }
        guard let data = decodeDataFromAny(value) else { return nil }
        if let text = decodeStringFromData(data) { return text }
        let lossy = String(decoding: data, as: UTF8.self)
        return lossy.isEmpty ? nil : lossy
    }

    private static func extractHTMLMarker(_ name: String, from html: String) -> String? {
        let startMarker = "(\(name))"
        let endMarker = "(/\(name))"

        guard let startRange = html.range(of: startMarker) else { return nil }
        guard let endRange = html.range(of: endMarker, range: startRange.upperBound..<html.endIndex) else { return nil }

        let payload = html[startRange.upperBound..<endRange.lowerBound]
        let trimmed = payload.trimmingCharacters(in: .whitespacesAndNewlines)
        return trimmed.isEmpty ? nil : String(trimmed)
    }

    private static func decodeFigmaMeta(_ base64: String) -> FigmaClipboardMeta? {
        let cleaned = base64.trimmingCharacters(in: .whitespacesAndNewlines)
        guard let data = Data(base64Encoded: cleaned) else { return nil }
        return try? JSONDecoder().decode(FigmaClipboardMeta.self, from: data)
    }

    private static func decodeStringFromData(_ data: Data?) -> String? {
        guard let data else { return nil }
        if let text = String(data: data, encoding: .utf8) { return text }
        if let text = String(data: data, encoding: .utf16) { return text }
        if let text = String(data: data, encoding: .utf16LittleEndian) { return text }
        if let text = String(data: data, encoding: .utf16BigEndian) { return text }
        return nil
    }

    private struct TextFallbackPayload {
        let pasteboardType: PasteboardType
        let data: Data
        let previewData: Data?
        let searchText: String
        let contentLength: Int
        let mode: String
    }

    private enum TextFallbackResolution {
        case payload(TextFallbackPayload)
        case figmaMarker
        case none
    }

    private static let utf16FallbackTypes: [PasteboardType] = [
        NSPasteboard.PasteboardType(rawValue: "public.utf16-external-plain-text"),
        NSPasteboard.PasteboardType(rawValue: "public.utf16-plain-text")
    ]

    private static let genericTextFallbackExcludedTypes: Set<PasteboardType> = [
        .string, .rtf, .rtfd, .flatRTFD, .html, .pdf, .fileURL,
        .microsoftObjectLink, .microsoftLinkSource,
        .universalClipboard, .autoGenerated, .source, .transient, .modified, .concealed,
        .linkPresentationMetadata, .customWebKitPasteboardData, .customChromiumWebData,
        .chromiumSourceUrl, .chromiumSourceToken, .notesRichText, .fromMaccy
    ]

    private static func resolveTextFallbackPayload(
        from item: NSPasteboardItem,
        filteredTypes: Set<PasteboardType>
    ) -> TextFallbackResolution {
        let htmlResult = resolveHTMLTextPayload(from: item)
        switch htmlResult {
        case .payload:
            return htmlResult
        case .figmaMarker:
            return .figmaMarker
        case .none:
            break
        }

        if let utf16Payload = resolveUTF16PlainText(from: item) {
            return .payload(utf16Payload)
        }

        if let genericPayload = resolveGenericTextPayload(from: item, filteredTypes: filteredTypes) {
            return .payload(genericPayload)
        }

        return .none
    }

    private static func resolveHTMLTextPayload(from item: NSPasteboardItem) -> TextFallbackResolution {
        let htmlString = item.string(forType: .html) ?? decodeStringFromData(item.data(forType: .html))
        guard let htmlString else { return .none }
        guard !htmlString.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return .none }

        if containsFigmaMarker(in: htmlString) {
            return .figmaMarker
        }

        let htmlData = item.data(forType: .html) ?? htmlString.data(using: .utf8)
        if let htmlData,
           let attributed = NSAttributedString(html: htmlData, documentAttributes: nil) {
            let rawText = attributed.string
            guard !normalizedPlainText(rawText).isEmpty else { return .none }

            if let rtfData = attributed.toData(with: .rtf) {
                let previewData = makePreviewData(from: attributed, type: .rtf)
                return .payload(
                    TextFallbackPayload(
                        pasteboardType: .rtf,
                        data: rtfData,
                        previewData: previewData,
                        searchText: rawText,
                        contentLength: attributed.length,
                        mode: "html->rtf"
                    )
                )
            }

            if let plainPayload = makePlainTextPayload(rawText, mode: "html->string") {
                return .payload(plainPayload)
            }
            return .none
        }

        if let plainPayload = makePlainTextPayload(htmlString, mode: "html-source-string") {
            return .payload(plainPayload)
        }

        return .none
    }

    private static func resolveUTF16PlainText(from item: NSPasteboardItem) -> TextFallbackPayload? {
        for type in utf16FallbackTypes {
            if let text = item.string(forType: type),
               let payload = makePlainTextPayload(text, mode: "utf16-string:\(type.rawValue)") {
                return payload
            }

            if let data = item.data(forType: type),
               let text = decodeStringFromData(data),
               let payload = makePlainTextPayload(text, mode: "utf16-data:\(type.rawValue)") {
                return payload
            }
        }
        return nil
    }

    private static func resolveGenericTextPayload(
        from item: NSPasteboardItem,
        filteredTypes: Set<PasteboardType>
    ) -> TextFallbackPayload? {
        for type in item.types where filteredTypes.contains(type) {
            if genericTextFallbackExcludedTypes.contains(type) { continue }
            if type.isImage() || type.isFile() { continue }

            guard let utType = UTType(type.rawValue), utType.conforms(to: .text) else { continue }

            if let text = item.string(forType: type),
               let payload = makePlainTextPayload(text, mode: "text-uti-string:\(type.rawValue)") {
                return payload
            }

            if let text = decodeStringFromData(item.data(forType: type)),
               let payload = makePlainTextPayload(text, mode: "text-uti-data:\(type.rawValue)") {
                return payload
            }
        }

        return nil
    }

    private static func makePlainTextPayload(_ text: String, mode: String) -> TextFallbackPayload? {
        guard !normalizedPlainText(text).isEmpty else { return nil }
        guard let data = text.data(using: .utf8) else { return nil }

        let attributed = NSAttributedString(string: text)
        let previewData = makePreviewData(from: attributed, type: .string)
        return TextFallbackPayload(
            pasteboardType: .string,
            data: data,
            previewData: previewData,
            searchText: text,
            contentLength: attributed.length,
            mode: mode
        )
    }

    private static func makePreviewData(from attributed: NSAttributedString, type: PasteboardType) -> Data? {
        let previewAttr = attributed.length > 250
            ? attributed.attributedSubstring(from: NSRange(location: 0, length: 250))
            : attributed
        return previewAttr.toData(with: type)
    }

    private static func containsFigmaMarker(in html: String) -> Bool {
        let lower = html.lowercased()
        return lower.contains("(figma)") || lower.contains("(/figma)")
    }
    
    var filePaths: [String]? {
        analysisLock.lock()
        if let cached = cachedFilePaths {
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        guard pasteboardType == .fileURL else { return nil }
        guard let urlString = String(data: data, encoding: .utf8) else { return nil }

        let paths: [String] = urlString.components(separatedBy: "\n")
            .compactMap { (entry: String) -> String? in
                let trimmed = entry.trimmingCharacters(in: .whitespacesAndNewlines)
                guard !trimmed.isEmpty else { return nil }

                // Handle both file URL strings (file://...) and plain paths.
                if let url = URL(string: trimmed), url.isFileURL {
                    return url.path
                }

                return trimmed
            }
            .filter { (path: String) in !path.isEmpty }

        analysisLock.lock()
        cachedFilePaths = paths
        analysisLock.unlock()
        return paths
    }

    var normalizedFilePaths: [String] {
        analysisLock.lock()
        if let cached = cachedNormalizedFilePaths {
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        guard let paths = filePaths else { return [] }
        let normalized = paths.map { Self.normalizeFilePath($0) }.filter { !$0.isEmpty }

        analysisLock.lock()
        cachedNormalizedFilePaths = normalized
        analysisLock.unlock()
        return normalized
    }

    func isFileMissingOnDisk() -> Bool {
        guard pasteboardType == .fileURL else { return false }
        let paths = normalizedFilePaths
        guard !paths.isEmpty else { return false }
        return !paths.contains { FileManager.default.fileExists(atPath: $0) }
    }

    private static func normalizeFilePath(_ raw: String) -> String {
        let trimmed = raw.trimmingCharacters(in: .whitespacesAndNewlines)
        guard trimmed.hasPrefix("file://") else { return trimmed }
        if let url = URL(string: trimmed) { return url.path }
        let spaceEscaped = trimmed.replacingOccurrences(of: " ", with: "%20")
        if let url = URL(string: spaceEscaped) { return url.path }
        let stripped = trimmed.replacingOccurrences(of: "file://", with: "")
        return stripped.removingPercentEncoding ?? stripped
    }

    private var primaryFilePath: String? {
        guard let paths = filePaths, let first = paths.first else { return nil }
        return Self.normalizeFilePath(first)
    }

    var imagePasteboardType: PasteboardType {
        if pasteboardType.isImage() {
            return pasteboardType
        }
        guard pasteboardType == .fileURL, let path = primaryFilePath else {
            return .png
        }
        let ext = (path as NSString).pathExtension.lowercased()
        if !ext.isEmpty, let type = UTType(filenameExtension: ext), type.conforms(to: .image) {
            return PasteboardType(type.identifier)
        }
        return .png
    }

    /// OCR text for image items; ignores file path tokens for fileURL images.
    var ocrTextForImage: String? {
        guard itemType == .image || isFileURLImage else { return nil }
        let trimmed = searchText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        if pasteboardType == .fileURL, let paths = filePaths {
            let fileText = Self.searchTextForFilePaths(paths)
                .trimmingCharacters(in: .whitespacesAndNewlines)
            if !fileText.isEmpty {
                if trimmed == fileText { return nil }
                if trimmed.hasPrefix(fileText) {
                    let remainder = trimmed.dropFirst(fileText.count)
                    let cleaned = String(remainder).trimmingCharacters(in: .whitespacesAndNewlines)
                    return cleaned.isEmpty ? nil : cleaned
                }
            }
        }

        return trimmed
    }

    static func searchTextForFilePaths(_ paths: [String]) -> String {
        let cleanedPaths = paths
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
        guard !cleanedPaths.isEmpty else { return "" }

        var tokens: [String] = []
        var seen = Set<String>()

        for rawPath in cleanedPaths {
            if seen.insert(rawPath).inserted {
                tokens.append(rawPath)
            }
            let normalizedPath = Self.normalizeFilePath(rawPath)
            let fileName = (normalizedPath as NSString).lastPathComponent
            if !fileName.isEmpty, seen.insert(fileName).inserted {
                tokens.append(fileName)
            }
        }

        return tokens.joined(separator: "\n")
    }
    
    init(
        pasteboardType: PasteboardType,
        data: Data,
        previewData: Data?,
        timestamp: Int64,
        appPath: String,
        appName: String,
        customTitle: String? = nil,
        sourceAnchor: SourceAnchor? = nil,
        searchText: String,
        contentLength: Int,
        tagId: Int = -1,
        isTemporary: Bool = false,
        id: Int64? = nil,
        uniqueId: String? = nil,
        blobPath: String? = nil,
        dataIsFull: Bool = true,
        dataLoader: (() -> Data?)? = nil
    ) {
        self.pasteboardType = pasteboardType
        self.inlineData = data
        self.previewData = previewData
        self.uniqueId = uniqueId ?? data.sha256Hex
        self.timestamp = timestamp
        self.appPath = appPath
        self.appName = appName
        self.customTitle = Self.normalizedCustomTitle(customTitle)
        self.sourceAnchor = sourceAnchor
        self.searchText = searchText
        self.contentLength = contentLength
        self.tagId = tagId
        self.isTemporary = isTemporary
        self.id = id
        self.blobPath = blobPath
        self.dataIsFull = dataIsFull
        self.fullDataLoader = dataLoader
        
        if pasteboardType == .fileURL {
            if let urlString = String(data: data, encoding: .utf8) {
                cachedFilePaths = urlString.components(separatedBy: "\n").filter { !$0.isEmpty }
            }
        }

        self.itemType = detectItemType()
    }

    var data: Data {
        inlineData
    }

    var hasFullData: Bool {
        dataIsFull
    }

    func setDeferredDataLoader(_ loader: @escaping () -> Data?) {
        fullDataLoader = loader
    }

    /// Load and cache full data when needed (for non-blob items).
    func loadFullData() -> Data? {
        if dataIsFull {
            return inlineData
        }

        dataLock.lock()
        defer { dataLock.unlock() }

        if dataIsFull {
            return inlineData
        }

        if let loaded = fullDataLoader?() {
            inlineData = loaded
            dataIsFull = true
            return loaded
        }

        return inlineData
    }
    
    convenience init?(with pasteboard: NSPasteboard, pasteboardItem: NSPasteboardItem? = nil) {
        guard let item = pasteboardItem ?? pasteboard.pasteboardItems?.first else { return nil }
        
        let app = NSWorkspace.shared.frontmostApplication
        let filteredTypes = Self.filteredPasteboardTypes(from: item.types)
        guard let type = PasteboardType.supportedTypes.first(where: { filteredTypes.contains($0) }) else {
            let rawTypes = item.types.map(\.rawValue).joined(separator: ",")
            switch Self.resolveTextFallbackPayload(from: item, filteredTypes: filteredTypes) {
            case .payload(let payload):
                log.debug("Creating item with text fallback [\(payload.mode)] types: [\(rawTypes)]")
                self.init(
                    pasteboardType: payload.pasteboardType,
                    data: payload.data,
                    previewData: payload.previewData,
                    timestamp: Int64(Date().timeIntervalSince1970),
                    appPath: app?.bundleURL?.path ?? "",
                    appName: app?.localizedName ?? "",
                    searchText: payload.searchText,
                    contentLength: payload.contentLength,
                    tagId: -1
                )
                return
            case .figmaMarker:
                log.debug("Text fallback aborted for Figma marker types: [\(rawTypes)]")
                return nil
            case .none:
                break
            }

            if let imageData = Self.imageDataFromPasteboard(pasteboard) {
                let previewData = Self.generatePreviewThumbnailData(from: imageData)
                self.init(
                    pasteboardType: .png,
                    data: imageData,
                    previewData: previewData,
                    timestamp: Int64(Date().timeIntervalSince1970),
                    appPath: app?.bundleURL?.path ?? "",
                    appName: app?.localizedName ?? "",
                    searchText: "",
                    contentLength: imageData.count,
                    tagId: -1
                )
                return
            }
            return nil
        }

        var resolvedType = type
        log.debug("Creating item with type: \(type.rawValue)")

        let plainTextCandidate = item.string(forType: .string)
        let normalizedPlainTextCandidate = plainTextCandidate.map { Self.normalizedPlainText($0) } ?? ""
        let hasPlainTextCandidate = !normalizedPlainTextCandidate.isEmpty

        var content: Data?
        var filePaths: [String] = []
        if (type == .rtfd || type == .flatRTFD),
           hasPlainTextCandidate,
           let plainData = plainTextCandidate?.data(using: .utf8) {
            // Prefer plain text for RTFD to avoid heavy decoding and NSSecureCoding warnings.
            resolvedType = .string
            content = plainData
        } else if type.isFile() {
            filePaths = Self.filePaths(from: pasteboard, item: item)

            guard !filePaths.isEmpty else { return nil }

            log.debug("File paths: \(filePaths)")
            let filePathsString = filePaths.joined(separator: "\n")
            content = filePathsString.data(using: .utf8) ?? Data()
        } else {
            content = item.data(forType: type)
            if content == nil, type.isImage(), let imageData = Self.imageDataFromPasteboard(pasteboard) {
                resolvedType = .png
                content = imageData
            }
        }
        
        guard let content = content else { return nil }
        
        var previewData: Data?
        var attributedString = NSAttributedString()
        
        if resolvedType.isText() {
            if (resolvedType == .rtf || resolvedType == .rtfd || resolvedType == .flatRTFD),
               hasPlainTextCandidate {
                // Avoid decoding RTF/RTFD when plain text is already available to sidestep Obj-C decode warnings.
                attributedString = NSAttributedString(string: plainTextCandidate ?? "")
            } else {
                attributedString = NSAttributedString(with: content, type: resolvedType) ?? NSAttributedString()
            }
            let trimmedText = Self.normalizedPlainText(attributedString.string)

            if trimmedText.isEmpty,
               (resolvedType == .rtf || resolvedType == .rtfd),
               let imageData = Self.imageDataFromAttributedString(attributedString) {
                let previewData = Self.generatePreviewThumbnailData(from: imageData)
                self.init(
                    pasteboardType: .png,
                    data: imageData,
                    previewData: previewData,
                    timestamp: Int64(Date().timeIntervalSince1970),
                    appPath: app?.bundleURL?.path ?? "",
                    appName: app?.localizedName ?? "",
                    searchText: "",
                    contentLength: imageData.count,
                    tagId: -1
                )
                return
            }

            guard !trimmedText.isEmpty else { return nil }
            
            if resolvedType == .rtf || resolvedType == .rtfd || resolvedType == .flatRTFD {
                // Avoid re-serializing rich text during parsing; keep original content as source of truth.
                previewData = nil
            } else {
                let previewAttr = attributedString.length > 250
                    ? attributedString.attributedSubstring(from: NSMakeRange(0, 250))
                    : attributedString
                previewData = previewAttr.toData(with: resolvedType)
            }
        }
        
        // 对于文本类型，使用字符长度；对于图片/文件，使用数据字节大小
        let length = resolvedType.isText() ? attributedString.length : content.count

        let searchText: String
        if resolvedType.isText() {
            searchText = attributedString.string
        } else if resolvedType.isFile() {
            searchText = Self.searchTextForFilePaths(filePaths)
        } else {
            searchText = ""
        }

        self.init(
            pasteboardType: resolvedType,
            data: content,
            previewData: previewData,
            timestamp: Int64(Date().timeIntervalSince1970),
            appPath: app?.bundleURL?.path ?? "",
            appName: app?.localizedName ?? "",
            searchText: searchText,
            contentLength: length,
            tagId: -1
        )
    }

    private static func filePaths(from pasteboard: NSPasteboard, item: NSPasteboardItem) -> [String] {
        if let urls = pasteboard.readObjects(
            forClasses: [NSURL.self],
            options: [.urlReadingFileURLsOnly: true]
        ) as? [NSURL] {
            let paths = urls.compactMap { $0.path }.filter { !$0.isEmpty }
            if !paths.isEmpty {
                return paths
            }
        }

        if let urlString = item.string(forType: .fileURL),
           let path = resolveFilePathToken(urlString) {
            return [path]
        }

        if let data = item.data(forType: .fileURL),
           let urlString = String(data: data, encoding: .utf8) {
            let paths = urlString.components(separatedBy: "\n")
                .compactMap { resolveFilePathToken($0) }
            if !paths.isEmpty {
                return paths
            }
        }

        return []
    }

    private static func resolveFilePathToken(_ token: String) -> String? {
        let trimmed = token.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }
        return normalizeFilePath(trimmed)
    }

    private static let microsoftSourcePrefix = "com.microsoft.ole.source."

    private static func filteredPasteboardTypes(from types: [PasteboardType]) -> Set<PasteboardType> {
        var filtered = Set(types)
        filtered = filtered.filter { !$0.rawValue.hasPrefix(microsoftSourcePrefix) }

        if filtered.contains(.microsoftLinkSource) && filtered.contains(.microsoftObjectLink) {
            filtered.subtract([.microsoftLinkSource, .microsoftObjectLink, .pdf])
        }

        return filtered
    }

    private static func normalizedPlainText(_ text: String) -> String {
        let stripped = text
            .replacingOccurrences(of: "\u{FFFC}", with: "")
            .replacingOccurrences(of: "\u{200B}", with: "")
            .replacingOccurrences(of: "\u{FEFF}", with: "")
        return stripped.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    static func normalizedCustomTitle(_ title: String?) -> String? {
        let trimmed = title?.trimmingCharacters(in: .whitespacesAndNewlines)
        guard let trimmed, !trimmed.isEmpty else { return nil }
        if trimmed.count > Const.customTitleMaxLength {
            return String(trimmed.prefix(Const.customTitleMaxLength))
        }
        return trimmed
    }

    private static func imageDataFromPasteboard(_ pasteboard: NSPasteboard) -> Data? {
        guard let image = NSImage(pasteboard: pasteboard) else { return nil }
        return pngData(from: image)
    }

    private static func imageDataFromAttributedString(_ attributedString: NSAttributedString) -> Data? {
        var foundImage: NSImage?

        attributedString.enumerateAttribute(.attachment, in: NSRange(location: 0, length: attributedString.length), options: []) { value, _, stop in
            guard let attachment = value as? NSTextAttachment else { return }

            if let image = attachment.image {
                foundImage = image
                stop.pointee = true
                return
            }

            if let fileWrapper = attachment.fileWrapper {
                if let data = fileWrapper.regularFileContents,
                   let image = NSImage(data: data) {
                    foundImage = image
                    stop.pointee = true
                    return
                }

                if let wrappers = fileWrapper.fileWrappers {
                    for wrapper in wrappers.values {
                        if let data = wrapper.regularFileContents,
                           let image = NSImage(data: data) {
                            foundImage = image
                            stop.pointee = true
                            return
                        }
                    }
                }
            }
        }

        guard let image = foundImage else { return nil }
        return pngData(from: image)
    }

    private static func pngData(from image: NSImage) -> Data? {
        guard let tiff = image.tiffRepresentation,
              let bitmap = NSBitmapImageRep(data: tiff) else { return nil }
        return bitmap.representation(using: .png, properties: [:])
    }
    
    private static let imageExtensions: Set<String> = [
        "png", "jpg", "jpeg", "gif", "bmp", "tiff", "tif", "heic", "heif", "webp", "ico", "icns", "raw", "cr2", "nef", "arw"
    ]

    private static let pdfExtensions: Set<String> = ["pdf"]
    private static let markdownExtensions: Set<String> = ["md", "markdown", "mdown", "mkd"]
    private static let officeExtensions: Set<String> = [
        "doc", "docx", "docm", "dot", "dotx",
        "xls", "xlsx", "xlsm", "xlt", "xltx",
        "ppt", "pptx", "pptm", "pot", "potx", "pps", "ppsx"
    ]

    /// 检查文件是否为 PDF
    var isPDF: Bool {
        guard itemType == .file, let rawPath = filePaths?.first else { return false }
        let firstPath = Self.normalizeFilePath(rawPath)
        let ext = (firstPath as NSString).pathExtension.lowercased()
        return Self.pdfExtensions.contains(ext)
    }

    /// Checks if a fileURL item points to image files (by extension/UTType).
    var isFileURLImage: Bool {
        guard pasteboardType == .fileURL, let paths = filePaths, !paths.isEmpty else { return false }
        return paths.allSatisfy { path in
            let resolvedPath = Self.normalizeFilePath(path)
            let ext = (resolvedPath as NSString).pathExtension.lowercased()
            if Self.imageExtensions.contains(ext) { return true }
            if !ext.isEmpty, let type = UTType(filenameExtension: ext), type.conforms(to: .image) {
                return true
            }
            return false
        }
    }

    /// 获取第一个 PDF 文件路径
    var firstPDFPath: String? {
        guard isPDF, let rawPath = filePaths?.first else { return nil }
        return Self.normalizeFilePath(rawPath)
    }

    /// 检查文件是否为 Markdown
    var isMarkdownFile: Bool {
        guard itemType == .file, let rawPath = filePaths?.first else { return false }
        let firstPath = Self.normalizeFilePath(rawPath)
        let ext = (firstPath as NSString).pathExtension.lowercased()
        return Self.markdownExtensions.contains(ext)
    }

    /// 获取第一个 Markdown 文件路径
    var firstMarkdownPath: String? {
        guard isMarkdownFile, let rawPath = filePaths?.first else { return nil }
        return Self.normalizeFilePath(rawPath)
    }

    /// Checks if the item is a single Office document that can use QuickLook.
    var officePreviewPath: String? {
        guard itemType == .file, let paths = filePaths, paths.count == 1, let rawPath = paths.first else {
            return nil
        }
        let firstPath = Self.normalizeFilePath(rawPath)
        let ext = (firstPath as NSString).pathExtension.lowercased()
        guard Self.officeExtensions.contains(ext) else { return nil }
        guard FileManager.default.fileExists(atPath: firstPath) else { return nil }
        return firstPath
    }
    
    private func detectItemType() -> ClipItemType {
        log.debug("detectItemType for pasteboardType: \(pasteboardType.rawValue)")
        
        if pasteboardType.isImage() {
            log.debug("Detected as image (\(pasteboardType.rawValue))")
            return .image
        }

        switch pasteboardType {
        case .fileURL:
            if isFileURLImage {
                log.debug("All files are images, returning .image")
                return .image
            }
            log.debug("Returning .file")
            return .file
        case .rtf, .rtfd, .flatRTFD:
            let rawText = searchText
            let trimmed = rawText.trimmingCharacters(in: .whitespacesAndNewlines)
            if trimmed.isHexColor { return .color }
            // URL detection should win over code detection (e.g. URLs inside markdown/rtf).
            if trimmed.asCompleteURL() != nil { return .url }
            let sample: String
            if contentLength > Const.maxSmartAnalysisLength,
               let end = rawText.index(rawText.startIndex, offsetBy: Const.maxSmartAnalysisLength, limitedBy: rawText.endIndex) {
                sample = String(rawText[..<end])
            } else {
                sample = rawText
            }
            if let language = SmartTextService.shared.detectCodeLanguage(in: sample), language != .markdown { return .code }
            if rawText.isCodeSnippet { return .code }
            return .richText
        case .string:
            let rawText = searchText
            let trimmed = rawText.trimmingCharacters(in: .whitespacesAndNewlines)
            if trimmed.isHexColor { return .color }
            if trimmed.asCompleteURL() != nil { return .url }
            let sample: String
            if contentLength > Const.maxSmartAnalysisLength,
               let end = rawText.index(rawText.startIndex, offsetBy: Const.maxSmartAnalysisLength, limitedBy: rawText.endIndex) {
                sample = String(rawText[..<end])
            } else {
                sample = rawText
            }
            if let language = SmartTextService.shared.detectCodeLanguage(in: sample), language != .markdown { return .code }
            if rawText.isCodeSnippet { return .code }
            return .text
        default:
            return .text
        }
    }
    
    private static let maxThumbnailSize: CGFloat = 400
    private static let maxImageDataSize: Int = 100 * 1024 * 1024 // 100MB limit for direct loading

    @ObservationIgnored
    private var cachedPDFThumbnail: NSImage?

    /// 使用 QLThumbnailGenerator 生成 PDF 首页缩略图 (卡片界面使用)
    func pdfThumbnail(size: CGSize = CGSize(width: 400, height: 400), completion: @escaping (NSImage?) -> Void) {
        // 返回缓存
        if let cached = cachedPDFThumbnail {
            completion(cached)
            return
        }

        guard let pdfPath = firstPDFPath else {
            completion(nil)
            return
        }
        guard FileManager.default.fileExists(atPath: pdfPath) else {
            completion(nil)
            return
        }

        let url = URL(fileURLWithPath: pdfPath)
        let request = QLThumbnailGenerator.Request(
            fileAt: url,
            size: size,
            scale: NSScreen.main?.backingScaleFactor ?? 2.0,
            representationTypes: .thumbnail
        )

        QLThumbnailGenerator.shared.generateRepresentations(for: request) { [weak self] thumbnail, _, error in
            DispatchQueue.main.async {
                if let thumbnail = thumbnail {
                    let image = thumbnail.nsImage
                    self?.cachedPDFThumbnail = image
                    completion(image)
                } else {
                    log.debug("PDF thumbnail generation failed: \(error?.localizedDescription ?? "unknown")")
                    // Fallback: 使用系统文件图标
                    let icon = IconCache.shared.icon(
                        forFile: pdfPath,
                        size: NSSize(width: size.width, height: size.height)
                    )
                    self?.cachedPDFThumbnail = icon
                    completion(icon)
                }
            }
        }
    }

    /// 同步获取 PDF 缩略图（如果已缓存）
    func cachedPDFThumbnailImage() -> NSImage? {
        return cachedPDFThumbnail
    }
    
    func thumbnail() -> NSImage? {
        analysisLock.lock()
        if let cached = cachedThumbnail {
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        guard itemType == .image else { return nil }

        // For file-based images
        if pasteboardType == .fileURL, let path = normalizedFilePaths.first {
            let thumb = generateThumbnailFromFile(path: path)
            analysisLock.lock()
            cachedThumbnail = thumb
            if let thumb { cachedImageSize = thumb.size }
            analysisLock.unlock()
            return thumb
        }

        // For pasteboard images (png, tiff)
        guard pasteboardType.isImage() else { return nil }

        if let previewData, let image = NSImage(data: previewData) {
            analysisLock.lock()
            cachedThumbnail = image
            cachedImageSize = image.size
            analysisLock.unlock()
            return image
        }

        guard let payload = resolvedData() else { return nil }

        let image: NSImage?
        if payload.count > Self.maxImageDataSize {
            image = generateSafeThumbnailFromData(payload)
        } else {
            image = NSImage(data: payload)
        }

        analysisLock.lock()
        cachedThumbnail = image
        if let image { cachedImageSize = image.size }
        analysisLock.unlock()
        return image
    }

    func base64Image(maxBytes: Int = Const.maxBase64ImageBytes) -> NSImage? {
        analysisLock.lock()
        if base64ImageChecked {
            let cached = cachedBase64Image
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        var result: NSImage? = nil
        defer {
            analysisLock.lock()
            cachedBase64Image = result
            base64ImageChecked = true
            analysisLock.unlock()
        }

        guard itemType == .text || itemType == .code || itemType == .richText else { return nil }
        let maxBase64Chars = (maxBytes * 4) / 3 + (maxBytes / 4) + 1024
        guard contentLength <= maxBase64Chars else { return nil }
        guard let payload = extractBase64ImagePayload(from: searchText, maxChars: maxBase64Chars) else { return nil }

        let normalized = normalizeBase64(payload)
        let estimatedBytes = normalized.count * 3 / 4
        guard estimatedBytes > 0 && estimatedBytes <= maxBytes else { return nil }

        guard let data = Data(base64Encoded: normalized, options: [.ignoreUnknownCharacters]),
              data.count <= maxBytes,
              let image = NSImage(data: data) else {
            return nil
        }

        result = image
        return image
    }
    
    private func generateThumbnailFromFile(path: String) -> NSImage? {
        guard FileManager.default.fileExists(atPath: path) else {
            let ext = URL(fileURLWithPath: path).pathExtension
            let contentType = UTType(filenameExtension: ext) ?? .data
            let icon = NSWorkspace.shared.icon(for: contentType)
            icon.size = NSSize(width: Self.maxThumbnailSize, height: Self.maxThumbnailSize)
            return icon
        }
        let url = URL(fileURLWithPath: path)
        
        // First try: Use QuickLook thumbnail generator
        let options: [CFString: Any] = [
            kCGImageSourceShouldCache: false,
            kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: Self.maxThumbnailSize
        ]
        
        if let source = CGImageSourceCreateWithURL(url as CFURL, nil),
           let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) {
            return NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
        }
        
        // Fallback 1: Try NSImage directly
        if let image = NSImage(contentsOf: url)?.resizedSafely(maxSize: Self.maxThumbnailSize) {
            return image
        }
        
        // Fallback 2: Use system file icon (always works in sandbox)
        return IconCache.shared.icon(
            forFile: path,
            size: NSSize(width: Self.maxThumbnailSize, height: Self.maxThumbnailSize)
        )
    }

    private func extractBase64ImagePayload(from text: String, maxChars: Int) -> String? {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        let payload: Substring
        if trimmed.hasPrefix("data:image/") {
            guard let commaRange = trimmed.range(of: ",") else { return nil }
            payload = trimmed[commaRange.upperBound...]
        } else {
            payload = trimmed[trimmed.startIndex...]
        }

        // 快速前缀探测：只检查前 16 个非空白 base64 字符
        let prefixLimit = 16
        var prefix = ""
        prefix.reserveCapacity(prefixLimit)
        for scalar in payload.unicodeScalars {
            if scalar.properties.isWhitespace { continue }
            prefix.append(Character(scalar))
            if prefix.count >= prefixLimit { break }
        }

        let lowercased = prefix.lowercased()
        let looksLikeImageBase64 =
            lowercased.hasPrefix("ivborw0kggo") || // PNG
            lowercased.hasPrefix("/9j/") ||        // JPEG
            lowercased.hasPrefix("r0lgod") ||      // GIF
            lowercased.hasPrefix("uklgr")          // WebP
        guard looksLikeImageBase64 else { return nil }

        let allowed = CharacterSet(charactersIn: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=_-")
        var cleaned = String()
        cleaned.reserveCapacity(min(maxChars, 4096))
        var count = 0
        for scalar in payload.unicodeScalars {
            if scalar.properties.isWhitespace { continue }
            guard allowed.contains(scalar) else { return nil }
            count += 1
            if count > maxChars { return nil }
            cleaned.append(Character(scalar))
        }

        guard count >= 128 else { return nil }
        return cleaned
    }

    private func normalizeBase64(_ input: String) -> String {
        var normalized = input
            .replacingOccurrences(of: "-", with: "+")
            .replacingOccurrences(of: "_", with: "/")

        let remainder = normalized.count % 4
        if remainder != 0 {
            normalized += String(repeating: "=", count: 4 - remainder)
        }

        return normalized
    }
    
    private func generateSafeThumbnailFromData(_ payload: Data) -> NSImage? {
        let options: [CFString: Any] = [
            kCGImageSourceShouldCache: false,
            kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: Self.maxThumbnailSize
        ]

        guard let source = CGImageSourceCreateWithData(payload as CFData, nil),
              let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else {
            return nil
        }

        return NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
    }

    /// 为大图预生成缩略图数据（用于存入数据库的 previewData）
    /// 在数据写入时调用，避免读取时解码大图
    static func generatePreviewThumbnailData(from imageData: Data, maxSize: CGFloat = 200) -> Data? {
        let options: [CFString: Any] = [
            kCGImageSourceShouldCache: false,
            kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: maxSize
        ]

        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
              let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else {
            return nil
        }

        // Convert CGImage to PNG data
        let bitmapRep = NSBitmapImageRep(cgImage: cgImage)
        return bitmapRep.representation(using: .png, properties: [:])
    }

    /// 异步生成预览缩略图数据
    static func generatePreviewThumbnailDataAsync(from imageData: Data, maxSize: CGFloat = 200) async -> Data? {
        await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .utility).async {
                let result = generatePreviewThumbnailData(from: imageData, maxSize: maxSize)
                continuation.resume(returning: result)
            }
        }
    }
    
    func imageSize() -> CGSize? {
        analysisLock.lock()
        if let cached = cachedImageSize {
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()

        guard itemType == .image else { return nil }

        var source: CGImageSource?

        if pasteboardType == .fileURL, let path = normalizedFilePaths.first {
            guard FileManager.default.fileExists(atPath: path) else { return nil }
            let url = URL(fileURLWithPath: path)
            source = CGImageSourceCreateWithURL(url as CFURL, nil)
        } else if pasteboardType.isImage(), let payload = resolvedData() {
            source = CGImageSourceCreateWithData(payload as CFData, nil)
        }

        guard let source,
              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [CFString: Any],
              let width = properties[kCGImagePropertyPixelWidth] as? CGFloat,
              let height = properties[kCGImagePropertyPixelHeight] as? CGFloat else {
            return nil
        }

        let size = CGSize(width: width, height: height)
        analysisLock.lock()
        cachedImageSize = size
        analysisLock.unlock()
        return size
    }
    
    func updateTag(_ newTagId: Int) {
        tagId = newTagId
    }
    
    func updateTimestamp() {
        timestamp = Int64(Date().timeIntervalSince1970)
    }
    
    func displayDescription() -> String {
        switch itemType {
        case .image:
            if let size = imageSize() {
                return "\(Int(size.width)) × \(Int(size.height))"
            }
            return "图片"
        case .text, .richText, .code:
            let formatted = DeckFormatters.decimalNumber().string(from: NSNumber(value: contentLength)) ?? "\(contentLength)"
            return "\(formatted) 个字符"
        case .file:
            guard let paths = filePaths else { return "文件" }
            if paths.count > 1 { return "\(paths.count) 个文件" }
            let firstPath = Self.normalizeFilePath(paths.first ?? "")
            return URL(fileURLWithPath: firstPath).lastPathComponent
        case .url:
            return String(data: data, encoding: .utf8) ?? "链接"
        case .color:
            return String(data: data, encoding: .utf8) ?? "颜色"
        }
    }
    
    func previewText(maxCharacters: Int = Const.maxPreviewBodyLength) -> (text: String, isTruncated: Bool) {
        let lengthHint: Int
        switch itemType {
        case .text, .richText, .code, .url, .color:
            lengthHint = contentLength
        default:
            lengthHint = searchText.count
        }
        guard lengthHint > maxCharacters else {
            return (searchText, false)
        }
        return (String(searchText.prefix(maxCharacters)) + "\n...", true)
    }
    
    /// 获取完整数据：若存在外部文件则优先读文件（自动解密），否则返回内存数据
    func resolvedData() -> Data? {
        if let blobPath, FileManager.default.fileExists(atPath: blobPath) {
            // 使用 BlobStorage.load() 自动处理解密
            return BlobStorage.shared.load(path: blobPath)
        }
        if itemType == .image, pasteboardType == .fileURL, let path = primaryFilePath {
            let fileURL = URL(fileURLWithPath: path)
            guard FileManager.default.fileExists(atPath: fileURL.path) else { return loadFullData() }
            if let attrs = try? FileManager.default.attributesOfItem(atPath: fileURL.path),
               let fileSize = attrs[.size] as? NSNumber,
               fileSize.intValue > Self.maxImageDataSize {
                return nil
            }
            return try? Data(contentsOf: fileURL, options: [.mappedIfSafe])
        }
        return loadFullData()
    }
    
    var smartAnalysis: SmartTextService.DetectionResult {
        analysisLock.lock()
        if let cachedSmartAnalysis {
            analysisLock.unlock()
            return cachedSmartAnalysis
        }
        analysisLock.unlock()

        let result = SmartTextService.shared.analyze(analysisSample)
        analysisLock.lock()
        cachedSmartAnalysis = result
        analysisLock.unlock()
        return result
    }
    
    var detectedCodeLanguage: SmartTextService.CodeLanguage? {
        smartAnalysis.codeLanguage
    }
    
    var isMarkdown: Bool {
        analysisLock.lock()
        if let cachedIsMarkdown {
            analysisLock.unlock()
            return cachedIsMarkdown
        }
        analysisLock.unlock()

        let detected = SmartTextService.shared.isMarkdown(analysisSample)
        analysisLock.lock()
        cachedIsMarkdown = detected
        analysisLock.unlock()
        return detected
    }

    /// 即时计算结果（如果文本是数学表达式）
    var calculationResult: SmartTextService.CalculationResult? {
        // 检查设置是否开启
        guard DeckUserDefaults.instantCalculation else {
            return nil
        }
        analysisLock.lock()
        if calculationResultChecked {
            let cached = cachedCalculationResult
            analysisLock.unlock()
            return cached
        }
        analysisLock.unlock()
        // 只对文本类型且长度合适的内容进行计算
        guard itemType == .text || itemType == .code else {
            analysisLock.lock()
            calculationResultChecked = true
            analysisLock.unlock()
            return nil
        }
        let result = SmartTextService.shared.detectAndCalculate(searchText)
        analysisLock.lock()
        cachedCalculationResult = result
        calculationResultChecked = true
        analysisLock.unlock()
        return result
    }

    var hasSmartContent: Bool {
        let analysis = smartAnalysis
        return !analysis.emails.isEmpty ||
               !analysis.urls.isEmpty ||
               !analysis.phones.isEmpty ||
               !analysis.ipAddresses.isEmpty ||
               analysis.codeLanguage != nil ||
               analysis.jwt != nil ||
               isMarkdown ||
               calculationResult != nil
    }
    
    static func == (lhs: ClipboardItem, rhs: ClipboardItem) -> Bool {
        lhs.uniqueId == rhs.uniqueId && lhs.id == rhs.id
    }
}

// MARK: - NSItemProvider support

extension ClipboardItem {
    func itemProvider() -> NSItemProvider {
        let provider = NSItemProvider()
        
        switch itemType {
        case .text, .code, .url, .color:
            if let str = String(data: data, encoding: .utf8) {
                return NSItemProvider(object: str as NSString)
            }
        case .richText:
            provider.registerDataRepresentation(forTypeIdentifier: pasteboardType.rawValue, visibility: .all) { [weak self] completion in
                let progress = Progress(totalUnitCount: 1)
                DispatchQueue.global(qos: .userInitiated).async {
                    guard let self, !progress.isCancelled else {
                        completion(nil, nil)
                        return
                    }

                    let data = self.resolvedData()
                    guard !progress.isCancelled else {
                        completion(nil, nil)
                        return
                    }

                    completion(data, nil)
                    progress.completedUnitCount = 1
                }
                return progress
            }
        case .image:
            let imageType = imagePasteboardType
            provider.registerDataRepresentation(forTypeIdentifier: imageType.rawValue, visibility: .all) { [weak self] completion in
                let progress = Progress(totalUnitCount: 1)
                DispatchQueue.global(qos: .userInitiated).async {
                    guard let self, !progress.isCancelled else {
                        completion(nil, nil)
                        return
                    }

                    let data = self.resolvedData()
                    guard !progress.isCancelled else {
                        completion(nil, nil)
                        return
                    }

                    completion(data, nil)
                    progress.completedUnitCount = 1
                }
                return progress
            }
            if pasteboardType == .fileURL, let path = primaryFilePath {
                provider.suggestedName = URL(fileURLWithPath: path).lastPathComponent
            } else {
                provider.suggestedName = appName + "-" + timestamp.formattedDate()
            }
        case .file:
            if let paths = filePaths {
                for rawPath in paths {
                    let path = Self.normalizeFilePath(rawPath)
                    let fileURL = URL(fileURLWithPath: path)
                    let typeId = UTType(filenameExtension: fileURL.pathExtension)?.identifier ?? UTType.data.identifier
                    provider.registerFileRepresentation(forTypeIdentifier: typeId, fileOptions: [], visibility: .all) { completion in
                        DispatchQueue.global(qos: .userInitiated).async {
                            if FileManager.default.fileExists(atPath: path) {
                                completion(fileURL, true, nil)
                            } else {
                                let error = NSError(domain: NSCocoaErrorDomain, code: NSFileReadNoSuchFileError)
                                completion(nil, false, error)
                            }
                        }
                        return nil
                    }
                }
                if paths.count == 1 {
                    let filePath = Self.normalizeFilePath(paths[0])
                    let fileName = URL(fileURLWithPath: filePath).lastPathComponent
                    let baseName: String
                    if let dotIndex = fileName.lastIndex(of: "."), dotIndex != fileName.startIndex {
                        baseName = String(fileName[..<dotIndex])
                    } else {
                        baseName = fileName
                    }
                    provider.suggestedName = baseName
                }
            }
        }
        
        return provider
    }
}
