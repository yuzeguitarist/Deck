//
//  ClipboardItem.swift
//  Deck
//
//  Deck Clipboard Manager
//

import AppKit
import Observation
import UniformTypeIdentifiers
import QuickLookThumbnailing
import PDFKit

typealias PasteboardType = NSPasteboard.PasteboardType

extension PasteboardType {
    // Image types first to prioritize image detection over fileURL
    static var supportedTypes: [PasteboardType] = [
        .png, .tiff, .jpeg, .heic, .heif, .gif, .webp, .bmp, .rtfd, .flatRTFD, .rtf, .fileURL, .string
    ]

    static let jpeg = NSPasteboard.PasteboardType("public.jpeg")
    static let heic = NSPasteboard.PasteboardType("public.heic")
    static let heif = NSPasteboard.PasteboardType("public.heif")
    static let gif = NSPasteboard.PasteboardType("com.compuserve.gif")
    static let webp = NSPasteboard.PasteboardType("org.webmproject.webp")
    static let bmp = NSPasteboard.PasteboardType("com.microsoft.bmp")
    static let flatRTFD = NSPasteboard.PasteboardType("com.apple.flat-rtfd")
    static let microsoftObjectLink = NSPasteboard.PasteboardType(rawValue: "com.microsoft.ObjectLink")
    static let microsoftLinkSource = NSPasteboard.PasteboardType(rawValue: "com.microsoft.Link-Source")
    static let universalClipboard = NSPasteboard.PasteboardType(rawValue: "com.apple.is-remote-clipboard")
    static let autoGenerated = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.AutoGeneratedType")
    static let concealed = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.ConcealedType")
    static let source = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.source")
    static let transient = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.TransientType")
    static let modified = NSPasteboard.PasteboardType(rawValue: "x.nspasteboard.ModifiedType")
    static let fromMaccy = NSPasteboard.PasteboardType(rawValue: "org.p0deje.Maccy")
    static let linkPresentationMetadata = NSPasteboard.PasteboardType(rawValue: "com.apple.linkpresentation.metadata")
    static let customWebKitPasteboardData = NSPasteboard.PasteboardType(rawValue: "com.apple.WebKit.custom-pasteboard-data")
    static let customChromiumWebData = NSPasteboard.PasteboardType(rawValue: "org.chromium.web-custom-data")
    static let chromiumSourceUrl = NSPasteboard.PasteboardType(rawValue: "org.chromium.source-url")
    static let chromiumSourceToken = NSPasteboard.PasteboardType(rawValue: "org.chromium.internal.source-rfh-token")
    static let notesRichText = NSPasteboard.PasteboardType(rawValue: "com.apple.notes.richtext")
    
    func isImage() -> Bool {
        if [.png, .tiff, .jpeg, .heic, .heif, .gif, .webp, .bmp].contains(self) { return true }
        if let utType = UTType(self.rawValue) {
            return utType.conforms(to: .image)
        }
        return false
    }
    
    func isText() -> Bool {
        !isImage() && !isFile()
    }
    
    func isFile() -> Bool {
        self == .fileURL
    }
}

enum ClipItemType: String, Codable, Sendable {
    case text
    case richText
    case image
    case file
    case url
    case color
    case code
    
    var displayName: String {
        switch self {
        case .text: return NSLocalizedString("文本", comment: "Text")
        case .richText: return NSLocalizedString("富文本", comment: "Rich Text")
        case .image: return NSLocalizedString("图片", comment: "Image")
        case .file: return NSLocalizedString("文件", comment: "File")
        case .url: return NSLocalizedString("链接", comment: "URL")
        case .color: return NSLocalizedString("颜色", comment: "Color")
        case .code: return NSLocalizedString("代码", comment: "Code")
        }
    }
    
    var icon: String {
        switch self {
        case .text: return "doc.text"
        case .richText: return "doc.richtext"
        case .image: return "photo"
        case .file: return "doc"
        case .url: return "link"
        case .color: return "paintpalette"
        case .code: return "chevron.left.forwardslash.chevron.right"
        }
    }
}

@Observable
final class ClipboardItem: Identifiable, Equatable {
    var id: Int64?
    let uniqueId: String
    let pasteboardType: PasteboardType
    @ObservationIgnored
    private var inlineData: Data
    let previewData: Data?
    let blobPath: String?
    private(set) var timestamp: Int64
    let appPath: String
    let appName: String
    var sourceAnchor: SourceAnchor?
    var searchText: String {
        didSet {
            guard searchText != oldValue else { return }
            base64ImageChecked = false
            cachedBase64Image = nil
            cachedSmartAnalysis = nil
            cachedIsMarkdown = nil
            cachedCalculationResult = nil
            calculationResultChecked = false
        }
    }
    let contentLength: Int
    var tagId: Int
    var isTemporary: Bool

    @ObservationIgnored
    private var dataIsFull: Bool

    @ObservationIgnored
    private var fullDataLoader: (() -> Data?)?

    @ObservationIgnored
    private let dataLock = NSLock()
    
    @ObservationIgnored
    private(set) lazy var itemType: ClipItemType = detectItemType()
    
    @ObservationIgnored
    private var cachedThumbnail: NSImage?
    
    @ObservationIgnored
    private var cachedImageSize: CGSize?
    
    @ObservationIgnored
    private var cachedFilePaths: [String]?
    
    @ObservationIgnored
    private var cachedColorValue: NSColor?

    @ObservationIgnored
    private var cachedBase64Image: NSImage?

    @ObservationIgnored
    private var base64ImageChecked: Bool = false
    
    @ObservationIgnored
    private var analysisSample: String {
        if searchText.count > Const.maxSmartAnalysisLength {
            return String(searchText.prefix(Const.maxSmartAnalysisLength))
        }
        return searchText
    }
    
    @ObservationIgnored
    private var cachedSmartAnalysis: SmartTextService.DetectionResult?
    
    @ObservationIgnored
    private var cachedIsMarkdown: Bool?

    @ObservationIgnored
    private var cachedCalculationResult: SmartTextService.CalculationResult?

    @ObservationIgnored
    private var calculationResultChecked: Bool = false
    
    var url: URL? {
        if pasteboardType == .string {
            let urlString = String(data: data, encoding: .utf8) ?? searchText
            return urlString.asCompleteURL()
        }
        if itemType == .url {
            return searchText.asCompleteURL()
        }
        return nil
    }
    
    var colorValue: NSColor? {
        if cachedColorValue != nil { return cachedColorValue }
        guard itemType == .color else { return nil }
        let text = String(data: data, encoding: .utf8) ?? ""
        cachedColorValue = text.hexColor
        return cachedColorValue
    }
    
    var filePaths: [String]? {
        if cachedFilePaths != nil { return cachedFilePaths }
        guard pasteboardType == .fileURL,
              let urlString = String(data: data, encoding: .utf8) else { return nil }
        cachedFilePaths = urlString.components(separatedBy: "\n").filter { !$0.isEmpty }
        return cachedFilePaths
    }

    private var primaryFilePath: String? {
        guard let paths = filePaths, let first = paths.first else { return nil }
        if first.hasPrefix("file://"), let url = URL(string: first) {
            return url.path
        }
        return first
    }

    var imagePasteboardType: PasteboardType {
        if pasteboardType.isImage() {
            return pasteboardType
        }
        guard pasteboardType == .fileURL, let path = primaryFilePath else {
            return .png
        }
        let ext = (path as NSString).pathExtension.lowercased()
        if !ext.isEmpty, let type = UTType(filenameExtension: ext), type.conforms(to: .image) {
            return PasteboardType(type.identifier)
        }
        return .png
    }

    /// OCR text for image items; ignores file path tokens for fileURL images.
    var ocrTextForImage: String? {
        guard itemType == .image || isFileURLImage else { return nil }
        let trimmed = searchText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        if pasteboardType == .fileURL, let paths = filePaths {
            let fileText = Self.searchTextForFilePaths(paths)
                .trimmingCharacters(in: .whitespacesAndNewlines)
            if !fileText.isEmpty {
                if trimmed == fileText { return nil }
                if trimmed.hasPrefix(fileText) {
                    let remainder = trimmed.dropFirst(fileText.count)
                    let cleaned = String(remainder).trimmingCharacters(in: .whitespacesAndNewlines)
                    return cleaned.isEmpty ? nil : cleaned
                }
            }
        }

        return trimmed
    }

    static func searchTextForFilePaths(_ paths: [String]) -> String {
        let cleanedPaths = paths
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
        guard !cleanedPaths.isEmpty else { return "" }

        var tokens: [String] = []
        var seen = Set<String>()

        for path in cleanedPaths {
            if seen.insert(path).inserted {
                tokens.append(path)
            }
            let fileName = URL(fileURLWithPath: path).lastPathComponent
            if !fileName.isEmpty, seen.insert(fileName).inserted {
                tokens.append(fileName)
            }
        }

        return tokens.joined(separator: "\n")
    }
    
    init(
        pasteboardType: PasteboardType,
        data: Data,
        previewData: Data?,
        timestamp: Int64,
        appPath: String,
        appName: String,
        sourceAnchor: SourceAnchor? = nil,
        searchText: String,
        contentLength: Int,
        tagId: Int = -1,
        isTemporary: Bool = false,
        id: Int64? = nil,
        uniqueId: String? = nil,
        blobPath: String? = nil,
        dataIsFull: Bool = true,
        dataLoader: (() -> Data?)? = nil
    ) {
        self.pasteboardType = pasteboardType
        self.inlineData = data
        self.previewData = previewData
        self.uniqueId = uniqueId ?? data.sha256Hex
        self.timestamp = timestamp
        self.appPath = appPath
        self.appName = appName
        self.sourceAnchor = sourceAnchor
        self.searchText = searchText
        self.contentLength = contentLength
        self.tagId = tagId
        self.isTemporary = isTemporary
        self.id = id
        self.blobPath = blobPath
        self.dataIsFull = dataIsFull
        self.fullDataLoader = dataLoader
        
        if pasteboardType == .fileURL {
            if let urlString = String(data: data, encoding: .utf8) {
                cachedFilePaths = urlString.components(separatedBy: "\n").filter { !$0.isEmpty }
            }
        }
    }

    var data: Data {
        inlineData
    }

    var hasFullData: Bool {
        dataIsFull
    }

    func setDeferredDataLoader(_ loader: @escaping () -> Data?) {
        fullDataLoader = loader
    }

    /// Load and cache full data when needed (for non-blob items).
    func loadFullData() -> Data? {
        if dataIsFull {
            return inlineData
        }

        dataLock.lock()
        defer { dataLock.unlock() }

        if dataIsFull {
            return inlineData
        }

        if let loaded = fullDataLoader?() {
            inlineData = loaded
            dataIsFull = true
            return loaded
        }

        return inlineData
    }
    
    convenience init?(with pasteboard: NSPasteboard) {
        guard let item = pasteboard.pasteboardItems?.first else { return nil }
        
        let app = NSWorkspace.shared.frontmostApplication
        let filteredTypes = Self.filteredPasteboardTypes(from: item.types)
        guard let type = PasteboardType.supportedTypes.first(where: { filteredTypes.contains($0) }) else {
            if let imageData = Self.imageDataFromPasteboard(pasteboard) {
                let previewData = Self.generatePreviewThumbnailData(from: imageData)
                self.init(
                    pasteboardType: .png,
                    data: imageData,
                    previewData: previewData,
                    timestamp: Int64(Date().timeIntervalSince1970),
                    appPath: app?.bundleURL?.path ?? "",
                    appName: app?.localizedName ?? "",
                    searchText: "",
                    contentLength: imageData.count,
                    tagId: -1
                )
                return
            }
            return nil
        }

        var resolvedType = type
        log.debug("Creating item with type: \(type.rawValue)")

        var content: Data?
        var filePaths: [String] = []
        if (type == .rtfd || type == .flatRTFD),
           let plain = item.string(forType: .string),
           !Self.normalizedPlainText(plain).isEmpty,
           let plainData = plain.data(using: .utf8) {
            // Prefer plain text for RTFD to avoid heavy decoding and NSSecureCoding warnings.
            resolvedType = .string
            content = plainData
        } else if type.isFile() {
            filePaths = Self.filePaths(from: pasteboard, item: item)

            guard !filePaths.isEmpty else { return nil }

            log.debug("File paths: \(filePaths)")
            let filePathsString = filePaths.joined(separator: "\n")
            content = filePathsString.data(using: .utf8) ?? Data()
        } else {
            content = item.data(forType: type)
            if content == nil, type.isImage(), let imageData = Self.imageDataFromPasteboard(pasteboard) {
                resolvedType = .png
                content = imageData
            }
        }
        
        guard let content = content else { return nil }
        
        var previewData: Data?
        var attributedString = NSAttributedString()
        
        if resolvedType.isText() {
            attributedString = NSAttributedString(with: content, type: resolvedType) ?? NSAttributedString()
            let trimmedText = Self.normalizedPlainText(attributedString.string)

            if trimmedText.isEmpty,
               (resolvedType == .rtf || resolvedType == .rtfd),
               let imageData = Self.imageDataFromAttributedString(attributedString) {
                let previewData = Self.generatePreviewThumbnailData(from: imageData)
                self.init(
                    pasteboardType: .png,
                    data: imageData,
                    previewData: previewData,
                    timestamp: Int64(Date().timeIntervalSince1970),
                    appPath: app?.bundleURL?.path ?? "",
                    appName: app?.localizedName ?? "",
                    searchText: "",
                    contentLength: imageData.count,
                    tagId: -1
                )
                return
            }

            guard !trimmedText.isEmpty else { return nil }
            
            let previewAttr = attributedString.length > 250
                ? attributedString.attributedSubstring(from: NSMakeRange(0, 250))
                : attributedString
            previewData = previewAttr.toData(with: resolvedType)
        }
        
        // 对于文本类型，使用字符长度；对于图片/文件，使用数据字节大小
        let length = resolvedType.isText() ? attributedString.length : content.count

        let searchText: String
        if resolvedType.isText() {
            searchText = attributedString.string
        } else if resolvedType.isFile() {
            searchText = Self.searchTextForFilePaths(filePaths)
        } else {
            searchText = ""
        }

        self.init(
            pasteboardType: resolvedType,
            data: content,
            previewData: previewData,
            timestamp: Int64(Date().timeIntervalSince1970),
            appPath: app?.bundleURL?.path ?? "",
            appName: app?.localizedName ?? "",
            searchText: searchText,
            contentLength: length,
            tagId: -1
        )
    }

    private static func filePaths(from pasteboard: NSPasteboard, item: NSPasteboardItem) -> [String] {
        if let urls = pasteboard.readObjects(
            forClasses: [NSURL.self],
            options: [.urlReadingFileURLsOnly: true]
        ) as? [NSURL] {
            let paths = urls.compactMap { $0.path }.filter { !$0.isEmpty }
            if !paths.isEmpty {
                return paths
            }
        }

        if let urlStrings = pasteboard.propertyList(forType: .fileURL) as? [String] {
            let paths = urlStrings.compactMap { resolveFilePathToken($0) }
            if !paths.isEmpty {
                return paths
            }
        } else if let urlString = pasteboard.propertyList(forType: .fileURL) as? String,
                  let path = resolveFilePathToken(urlString) {
            return [path]
        }

        if let urlString = item.string(forType: .fileURL),
           let path = resolveFilePathToken(urlString) {
            return [path]
        }

        if let data = item.data(forType: .fileURL),
           let urlString = String(data: data, encoding: .utf8) {
            let paths = urlString.components(separatedBy: "\n")
                .compactMap { resolveFilePathToken($0) }
            if !paths.isEmpty {
                return paths
            }
        }

        return []
    }

    private static func resolveFilePathToken(_ token: String) -> String? {
        let trimmed = token.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }
        if trimmed.hasPrefix("file://"), let url = URL(string: trimmed) {
            return url.path
        }
        return trimmed
    }

    private static let microsoftSourcePrefix = "com.microsoft.ole.source."

    private static func filteredPasteboardTypes(from types: [PasteboardType]) -> Set<PasteboardType> {
        var filtered = Set(types)
        filtered = filtered.filter { !$0.rawValue.hasPrefix(microsoftSourcePrefix) }

        if filtered.contains(.microsoftLinkSource) && filtered.contains(.microsoftObjectLink) {
            filtered.subtract([.microsoftLinkSource, .microsoftObjectLink, .pdf])
        }

        return filtered
    }

    private static func normalizedPlainText(_ text: String) -> String {
        let stripped = text
            .replacingOccurrences(of: "\u{FFFC}", with: "")
            .replacingOccurrences(of: "\u{200B}", with: "")
            .replacingOccurrences(of: "\u{FEFF}", with: "")
        return stripped.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private static func imageDataFromPasteboard(_ pasteboard: NSPasteboard) -> Data? {
        guard let image = NSImage(pasteboard: pasteboard) else { return nil }
        return pngData(from: image)
    }

    private static func imageDataFromAttributedString(_ attributedString: NSAttributedString) -> Data? {
        var foundImage: NSImage?

        attributedString.enumerateAttribute(.attachment, in: NSRange(location: 0, length: attributedString.length), options: []) { value, _, stop in
            guard let attachment = value as? NSTextAttachment else { return }

            if let image = attachment.image {
                foundImage = image
                stop.pointee = true
                return
            }

            if let fileWrapper = attachment.fileWrapper {
                if let data = fileWrapper.regularFileContents,
                   let image = NSImage(data: data) {
                    foundImage = image
                    stop.pointee = true
                    return
                }

                if let wrappers = fileWrapper.fileWrappers {
                    for wrapper in wrappers.values {
                        if let data = wrapper.regularFileContents,
                           let image = NSImage(data: data) {
                            foundImage = image
                            stop.pointee = true
                            return
                        }
                    }
                }
            }
        }

        guard let image = foundImage else { return nil }
        return pngData(from: image)
    }

    private static func pngData(from image: NSImage) -> Data? {
        guard let tiff = image.tiffRepresentation,
              let bitmap = NSBitmapImageRep(data: tiff) else { return nil }
        return bitmap.representation(using: .png, properties: [:])
    }
    
    private static let imageExtensions: Set<String> = [
        "png", "jpg", "jpeg", "gif", "bmp", "tiff", "tif", "heic", "heif", "webp", "ico", "icns", "raw", "cr2", "nef", "arw"
    ]

    private static let pdfExtensions: Set<String> = ["pdf"]
    private static let markdownExtensions: Set<String> = ["md", "markdown", "mdown", "mkd"]
    private static let officeExtensions: Set<String> = [
        "doc", "docx", "docm", "dot", "dotx",
        "xls", "xlsx", "xlsm", "xlt", "xltx",
        "ppt", "pptx", "pptm", "pot", "potx", "pps", "ppsx"
    ]

    /// 检查文件是否为 PDF
    var isPDF: Bool {
        guard itemType == .file, let paths = filePaths, let firstPath = paths.first else { return false }
        let ext = (firstPath as NSString).pathExtension.lowercased()
        return Self.pdfExtensions.contains(ext)
    }

    /// Checks if a fileURL item points to image files (by extension/UTType).
    var isFileURLImage: Bool {
        guard pasteboardType == .fileURL, let paths = filePaths, !paths.isEmpty else { return false }
        return paths.allSatisfy { path in
            let resolvedPath: String
            if path.hasPrefix("file://"), let url = URL(string: path) {
                resolvedPath = url.path
            } else {
                resolvedPath = path
            }
            let ext = (resolvedPath as NSString).pathExtension.lowercased()
            if Self.imageExtensions.contains(ext) { return true }
            if !ext.isEmpty, let type = UTType(filenameExtension: ext), type.conforms(to: .image) {
                return true
            }
            return false
        }
    }

    /// 获取第一个 PDF 文件路径
    var firstPDFPath: String? {
        guard isPDF, let paths = filePaths else { return nil }
        return paths.first
    }

    /// 检查文件是否为 Markdown
    var isMarkdownFile: Bool {
        guard itemType == .file, let paths = filePaths, let firstPath = paths.first else { return false }
        let ext = (firstPath as NSString).pathExtension.lowercased()
        return Self.markdownExtensions.contains(ext)
    }

    /// 获取第一个 Markdown 文件路径
    var firstMarkdownPath: String? {
        guard isMarkdownFile, let paths = filePaths else { return nil }
        return paths.first
    }

    /// Checks if the item is a single Office document that can use QuickLook.
    var officePreviewPath: String? {
        guard itemType == .file, let paths = filePaths, paths.count == 1, let firstPath = paths.first else {
            return nil
        }
        let ext = (firstPath as NSString).pathExtension.lowercased()
        guard Self.officeExtensions.contains(ext) else { return nil }
        guard FileManager.default.fileExists(atPath: firstPath) else { return nil }
        return firstPath
    }
    
    private func detectItemType() -> ClipItemType {
        log.debug("detectItemType for pasteboardType: \(pasteboardType.rawValue)")
        
        if pasteboardType.isImage() {
            log.debug("Detected as image (\(pasteboardType.rawValue))")
            return .image
        }

        switch pasteboardType {
        case .fileURL:
            // Ensure cachedFilePaths is initialized
            if cachedFilePaths == nil {
                if let urlString = String(data: data, encoding: .utf8) {
                    cachedFilePaths = urlString.components(separatedBy: "\n").filter { !$0.isEmpty }
                }
            }
            if isFileURLImage {
                log.debug("All files are images, returning .image")
                return .image
            }
            log.debug("Returning .file")
            return .file
        case .rtf, .rtfd, .flatRTFD:
            let text = searchText
            if text.isHexColor { return .color }
            if text.asCompleteURL() != nil { return .url }
            if text.isCodeSnippet { return .code }
            return .richText
        case .string:
            let text = String(data: data, encoding: .utf8) ?? ""
            if text.isHexColor { return .color }
            if text.asCompleteURL() != nil { return .url }
            if text.isCodeSnippet { return .code }
            return .text
        default:
            return .text
        }
    }
    
    private static let maxThumbnailSize: CGFloat = 400
    private static let maxImageDataSize: Int = 100 * 1024 * 1024 // 100MB limit for direct loading

    @ObservationIgnored
    private var cachedPDFThumbnail: NSImage?

    /// 使用 QLThumbnailGenerator 生成 PDF 首页缩略图 (卡片界面使用)
    func pdfThumbnail(size: CGSize = CGSize(width: 400, height: 400), completion: @escaping (NSImage?) -> Void) {
        // 返回缓存
        if let cached = cachedPDFThumbnail {
            completion(cached)
            return
        }

        guard let pdfPath = firstPDFPath else {
            completion(nil)
            return
        }
        guard FileManager.default.fileExists(atPath: pdfPath) else {
            completion(nil)
            return
        }

        let url = URL(fileURLWithPath: pdfPath)
        let request = QLThumbnailGenerator.Request(
            fileAt: url,
            size: size,
            scale: NSScreen.main?.backingScaleFactor ?? 2.0,
            representationTypes: .thumbnail
        )

        QLThumbnailGenerator.shared.generateRepresentations(for: request) { [weak self] thumbnail, _, error in
            DispatchQueue.main.async {
                if let thumbnail = thumbnail {
                    let image = thumbnail.nsImage
                    self?.cachedPDFThumbnail = image
                    completion(image)
                } else {
                    log.debug("PDF thumbnail generation failed: \(error?.localizedDescription ?? "unknown")")
                    // Fallback: 使用系统文件图标
                    let icon = NSWorkspace.shared.icon(forFile: pdfPath)
                    icon.size = NSSize(width: size.width, height: size.height)
                    self?.cachedPDFThumbnail = icon
                    completion(icon)
                }
            }
        }
    }

    /// 同步获取 PDF 缩略图（如果已缓存）
    func cachedPDFThumbnailImage() -> NSImage? {
        return cachedPDFThumbnail
    }
    
    func thumbnail() -> NSImage? {
        if let cached = cachedThumbnail { return cached }
        guard itemType == .image else { return nil }
        
        // For file-based images
        if pasteboardType == .fileURL, let paths = cachedFilePaths, let path = paths.first {
            cachedThumbnail = generateThumbnailFromFile(path: path)
            return cachedThumbnail
        }
        
        // For pasteboard images (png, tiff)
        guard pasteboardType.isImage() else { return nil }
        
        if let previewData, let image = NSImage(data: previewData) {
            cachedThumbnail = image
            return cachedThumbnail
        }
        
        // Safety check for large data
        guard let payload = resolvedData() else { return nil }
        if payload.count > Self.maxImageDataSize {
            cachedThumbnail = generateSafeThumbnailFromData()
            return cachedThumbnail
        }
        
        cachedThumbnail = NSImage(data: payload)
        return cachedThumbnail
    }

    func base64Image(maxBytes: Int = Const.maxBase64ImageBytes) -> NSImage? {
        if base64ImageChecked { return cachedBase64Image }
        base64ImageChecked = true

        guard itemType == .text || itemType == .code || itemType == .richText else { return nil }
        guard let payload = extractBase64ImagePayload(from: searchText) else { return nil }

        let normalized = normalizeBase64(payload)
        let estimatedBytes = normalized.count * 3 / 4
        guard estimatedBytes > 0 && estimatedBytes <= maxBytes else { return nil }

        guard let data = Data(base64Encoded: normalized, options: [.ignoreUnknownCharacters]),
              data.count <= maxBytes,
              let image = NSImage(data: data) else {
            return nil
        }

        cachedBase64Image = image
        return image
    }
    
    private func generateThumbnailFromFile(path: String) -> NSImage? {
        guard FileManager.default.fileExists(atPath: path) else {
            let ext = URL(fileURLWithPath: path).pathExtension
            let contentType = UTType(filenameExtension: ext) ?? .data
            let icon = NSWorkspace.shared.icon(for: contentType)
            icon.size = NSSize(width: Self.maxThumbnailSize, height: Self.maxThumbnailSize)
            return icon
        }
        let url = URL(fileURLWithPath: path)
        
        // First try: Use QuickLook thumbnail generator
        let options: [CFString: Any] = [
            kCGImageSourceShouldCache: false,
            kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: Self.maxThumbnailSize
        ]
        
        if let source = CGImageSourceCreateWithURL(url as CFURL, nil),
           let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) {
            return NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
        }
        
        // Fallback 1: Try NSImage directly
        if let image = NSImage(contentsOf: url)?.resizedSafely(maxSize: Self.maxThumbnailSize) {
            return image
        }
        
        // Fallback 2: Use system file icon (always works in sandbox)
        let icon = NSWorkspace.shared.icon(forFile: path)
        icon.size = NSSize(width: Self.maxThumbnailSize, height: Self.maxThumbnailSize)
        return icon
    }

    private func extractBase64ImagePayload(from text: String) -> String? {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)

        if trimmed.hasPrefix("data:image/") {
            guard let commaRange = trimmed.range(of: ",") else { return nil }
            return String(trimmed[commaRange.upperBound...])
        }

        let cleaned = trimmed.replacingOccurrences(of: "\\s", with: "", options: .regularExpression)
        guard cleaned.count >= 128 else { return nil }

        let lowercased = cleaned.lowercased()
        let looksLikeImageBase64 =
            lowercased.hasPrefix("ivborw0kggo") || // PNG
            lowercased.hasPrefix("/9j/") ||        // JPEG
            lowercased.hasPrefix("r0lgod") ||      // GIF
            lowercased.hasPrefix("uklgr")          // WebP

        guard looksLikeImageBase64 else { return nil }

        let allowed = CharacterSet(charactersIn: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=_-")
        guard cleaned.unicodeScalars.allSatisfy({ allowed.contains($0) }) else { return nil }

        return cleaned
    }

    private func normalizeBase64(_ input: String) -> String {
        var normalized = input
            .replacingOccurrences(of: "-", with: "+")
            .replacingOccurrences(of: "_", with: "/")

        let remainder = normalized.count % 4
        if remainder != 0 {
            normalized += String(repeating: "=", count: 4 - remainder)
        }

        return normalized
    }
    
    private func generateSafeThumbnailFromData() -> NSImage? {
        let options: [CFString: Any] = [
            kCGImageSourceShouldCache: false,
            kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: Self.maxThumbnailSize
        ]

        guard let payload = resolvedData(),
              let source = CGImageSourceCreateWithData(payload as CFData, nil),
              let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else {
            return nil
        }

        return NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
    }

    /// 为大图预生成缩略图数据（用于存入数据库的 previewData）
    /// 在数据写入时调用，避免读取时解码大图
    static func generatePreviewThumbnailData(from imageData: Data, maxSize: CGFloat = 200) -> Data? {
        let options: [CFString: Any] = [
            kCGImageSourceShouldCache: false,
            kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: maxSize
        ]

        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
              let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else {
            return nil
        }

        // Convert CGImage to PNG data
        let bitmapRep = NSBitmapImageRep(cgImage: cgImage)
        return bitmapRep.representation(using: .png, properties: [:])
    }

    /// 异步生成预览缩略图数据
    static func generatePreviewThumbnailDataAsync(from imageData: Data, maxSize: CGFloat = 200) async -> Data? {
        await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .utility).async {
                let result = generatePreviewThumbnailData(from: imageData, maxSize: maxSize)
                continuation.resume(returning: result)
            }
        }
    }
    
    func imageSize() -> CGSize? {
        if let cached = cachedImageSize { return cached }
        guard itemType == .image else { return nil }
        
        var source: CGImageSource?
        if pasteboardType == .fileURL, let paths = cachedFilePaths, let path = paths.first {
            guard FileManager.default.fileExists(atPath: path) else { return nil }
            let url = URL(fileURLWithPath: path)
            source = CGImageSourceCreateWithURL(url as CFURL, nil)
        } else if pasteboardType.isImage(), let payload = resolvedData() {
            source = CGImageSourceCreateWithData(payload as CFData, nil)
        }
        
        guard let source = source,
              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [CFString: Any] else {
            return nil
        }
        
        guard let width = properties[kCGImagePropertyPixelWidth] as? CGFloat,
              let height = properties[kCGImagePropertyPixelHeight] as? CGFloat else {
            return nil
        }
        
        let dpi = properties[kCGImagePropertyDPIWidth] as? CGFloat ?? 72.0
        let scale = dpi / 72.0
        let size = CGSize(width: width / scale, height: height / scale)
        cachedImageSize = size
        return size
    }
    
    func updateTag(_ newTagId: Int) {
        tagId = newTagId
    }
    
    func updateTimestamp() {
        timestamp = Int64(Date().timeIntervalSince1970)
    }
    
    func displayDescription() -> String {
        switch itemType {
        case .image:
            if let size = imageSize() {
                return "\(Int(size.width)) × \(Int(size.height))"
            }
            return "图片"
        case .text, .richText, .code:
            let formatter = NumberFormatter()
            formatter.numberStyle = .decimal
            return "\(formatter.string(from: NSNumber(value: contentLength)) ?? "\(contentLength)") 个字符"
        case .file:
            guard let paths = filePaths else { return "文件" }
            return paths.count > 1 ? "\(paths.count) 个文件" : (URL(fileURLWithPath: paths.first ?? "").lastPathComponent)
        case .url:
            return String(data: data, encoding: .utf8) ?? "链接"
        case .color:
            return String(data: data, encoding: .utf8) ?? "颜色"
        }
    }
    
    func previewText(maxCharacters: Int = Const.maxPreviewBodyLength) -> (text: String, isTruncated: Bool) {
        guard searchText.count > maxCharacters else {
            return (searchText, false)
        }
        return (String(searchText.prefix(maxCharacters)) + "\n...", true)
    }
    
    /// 获取完整数据：若存在外部文件则优先读文件（自动解密），否则返回内存数据
    func resolvedData() -> Data? {
        if let blobPath, FileManager.default.fileExists(atPath: blobPath) {
            // 使用 BlobStorage.load() 自动处理解密
            return BlobStorage.shared.load(path: blobPath)
        }
        if itemType == .image, pasteboardType == .fileURL, let path = primaryFilePath {
            let fileURL = URL(fileURLWithPath: path)
            if FileManager.default.fileExists(atPath: fileURL.path) {
                return try? Data(contentsOf: fileURL)
            }
        }
        return loadFullData()
    }
    
    var smartAnalysis: SmartTextService.DetectionResult {
        if let cachedSmartAnalysis {
            return cachedSmartAnalysis
        }
        let result = SmartTextService.shared.analyze(analysisSample)
        cachedSmartAnalysis = result
        return result
    }
    
    var detectedCodeLanguage: SmartTextService.CodeLanguage? {
        smartAnalysis.codeLanguage
    }
    
    var isMarkdown: Bool {
        if let cachedIsMarkdown {
            return cachedIsMarkdown
        }
        let detected = SmartTextService.shared.isMarkdown(analysisSample)
        cachedIsMarkdown = detected
        return detected
    }

    /// 即时计算结果（如果文本是数学表达式）
    var calculationResult: SmartTextService.CalculationResult? {
        // 检查设置是否开启
        guard DeckUserDefaults.instantCalculation else {
            return nil
        }
        if calculationResultChecked {
            return cachedCalculationResult
        }
        // 只对文本类型且长度合适的内容进行计算
        guard itemType == .text || itemType == .code else {
            calculationResultChecked = true
            return nil
        }
        cachedCalculationResult = SmartTextService.shared.detectAndCalculate(searchText)
        calculationResultChecked = true
        return cachedCalculationResult
    }

    var hasSmartContent: Bool {
        let analysis = smartAnalysis
        return !analysis.emails.isEmpty ||
               !analysis.phones.isEmpty ||
               analysis.codeLanguage != nil ||
               analysis.jwt != nil ||
               isMarkdown ||
               calculationResult != nil
    }
    
    static func == (lhs: ClipboardItem, rhs: ClipboardItem) -> Bool {
        lhs.uniqueId == rhs.uniqueId && lhs.id == rhs.id
    }
}

// MARK: - NSItemProvider support

extension ClipboardItem {
    func itemProvider() -> NSItemProvider {
        let provider = NSItemProvider()
        
        switch itemType {
        case .text, .code, .url, .color:
            if let str = String(data: data, encoding: .utf8) {
                return NSItemProvider(object: str as NSString)
            }
        case .richText:
            provider.registerDataRepresentation(forTypeIdentifier: pasteboardType.rawValue, visibility: .all) { [weak self] completion in
                guard let data = self?.resolvedData() else {
                    completion(nil, nil)
                    return nil
                }
                DispatchQueue.global(qos: .userInitiated).async {
                    completion(data, nil)
                }
                return nil
            }
        case .image:
            let imageType = imagePasteboardType
            provider.registerDataRepresentation(forTypeIdentifier: imageType.rawValue, visibility: .all) { [weak self] completion in
                guard let data = self?.resolvedData() else {
                    completion(nil, nil)
                    return nil
                }
                DispatchQueue.global(qos: .userInitiated).async {
                    completion(data, nil)
                }
                return nil
            }
            if pasteboardType == .fileURL, let path = primaryFilePath {
                provider.suggestedName = URL(fileURLWithPath: path).lastPathComponent
            } else {
                provider.suggestedName = appName + "-" + timestamp.formattedDate()
            }
        case .file:
            if let paths = filePaths {
                for path in paths {
                    let fileURL = URL(fileURLWithPath: path)
                    let typeId = UTType(filenameExtension: fileURL.pathExtension)?.identifier ?? UTType.data.identifier
                    provider.registerFileRepresentation(forTypeIdentifier: typeId, fileOptions: [], visibility: .all) { completion in
                        DispatchQueue.global(qos: .userInitiated).async {
                            if FileManager.default.fileExists(atPath: path) {
                                completion(fileURL, true, nil)
                            } else {
                                let error = NSError(domain: NSCocoaErrorDomain, code: NSFileReadNoSuchFileError)
                                completion(nil, false, error)
                            }
                        }
                        return nil
                    }
                }
                if paths.count == 1 {
                    provider.suggestedName = URL(fileURLWithPath: paths[0]).lastPathComponent
                }
            }
        }
        
        return provider
    }
}
